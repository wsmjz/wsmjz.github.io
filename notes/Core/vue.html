<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | 苹果家+</title>
    <meta name="description" content="苹果家+，不只是代码，更是一群朋友的空间">
    
    
    <link rel="preload" href="/vuepress/assets/css/0.styles.9f7574c5.css" as="style"><link rel="preload" href="/vuepress/assets/js/app.e32c95c2.js" as="script"><link rel="preload" href="/vuepress/assets/js/2.9a8b6d54.js" as="script"><link rel="preload" href="/vuepress/assets/js/10.11b9baea.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/11.87d43144.js"><link rel="prefetch" href="/vuepress/assets/js/12.88b4be69.js"><link rel="prefetch" href="/vuepress/assets/js/13.b75736a5.js"><link rel="prefetch" href="/vuepress/assets/js/14.a2e178ee.js"><link rel="prefetch" href="/vuepress/assets/js/15.b2082756.js"><link rel="prefetch" href="/vuepress/assets/js/16.8d3efe6f.js"><link rel="prefetch" href="/vuepress/assets/js/17.cb5dd6a4.js"><link rel="prefetch" href="/vuepress/assets/js/18.c5937895.js"><link rel="prefetch" href="/vuepress/assets/js/19.0d0c9d0c.js"><link rel="prefetch" href="/vuepress/assets/js/20.29c9b6c6.js"><link rel="prefetch" href="/vuepress/assets/js/3.523eba35.js"><link rel="prefetch" href="/vuepress/assets/js/4.583dc5ab.js"><link rel="prefetch" href="/vuepress/assets/js/5.e91b76f4.js"><link rel="prefetch" href="/vuepress/assets/js/6.53c1b3df.js"><link rel="prefetch" href="/vuepress/assets/js/7.808eccaf.js"><link rel="prefetch" href="/vuepress/assets/js/8.3165a768.js"><link rel="prefetch" href="/vuepress/assets/js/9.fab58f37.js">
    <link rel="stylesheet" href="/vuepress/assets/css/0.styles.9f7574c5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress/" class="home-link router-link-active"><!----> <span class="site-name">苹果家+</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">核心</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/Core/Core/Api.html" class="nav-link">重要Api</a></li><li class="dropdown-item"><!----> <a href="/vuepress/Core/Core/vue.html" class="nav-link">Vue概记</a></li><li class="dropdown-item"><!----> <a href="/vuepress/Core/Core/react.html" class="nav-link">React概记</a></li><li class="dropdown-item"><!----> <a href="/vuepress/Core/webpack/my_webpack.html" class="nav-link">Webpack</a></li><li class="dropdown-item"><!----> <a href="/vuepress/Core/note12.html" class="nav-link">zf-webpack</a></li></ul></div></div><div class="nav-item"><a href="/vuepress/Core/zaji/base.html" class="nav-link">杂记</a></div><div class="nav-item"><a href="/vuepress/Core/Cansee/base.html" class="nav-link">可视化</a></div><div class="nav-item"><a href="/vuepress/xcx.html" class="nav-link">小程序</a></div><div class="nav-item"><a href="/vuepress/cli.html" class="nav-link">脚手架</a></div><div class="nav-item"><a href="/vuepress/Core/node_note/base/note.html" class="nav-link">node.js</a></div><div class="nav-item"><a href="/vuepress/guoxue.html" class="nav-link">国学</a></div> <a href="https://github.com/wsmjz" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">核心</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress/Core/Core/Api.html" class="nav-link">重要Api</a></li><li class="dropdown-item"><!----> <a href="/vuepress/Core/Core/vue.html" class="nav-link">Vue概记</a></li><li class="dropdown-item"><!----> <a href="/vuepress/Core/Core/react.html" class="nav-link">React概记</a></li><li class="dropdown-item"><!----> <a href="/vuepress/Core/webpack/my_webpack.html" class="nav-link">Webpack</a></li><li class="dropdown-item"><!----> <a href="/vuepress/Core/note12.html" class="nav-link">zf-webpack</a></li></ul></div></div><div class="nav-item"><a href="/vuepress/Core/zaji/base.html" class="nav-link">杂记</a></div><div class="nav-item"><a href="/vuepress/Core/Cansee/base.html" class="nav-link">可视化</a></div><div class="nav-item"><a href="/vuepress/xcx.html" class="nav-link">小程序</a></div><div class="nav-item"><a href="/vuepress/cli.html" class="nav-link">脚手架</a></div><div class="nav-item"><a href="/vuepress/Core/node_note/base/note.html" class="nav-link">node.js</a></div><div class="nav-item"><a href="/vuepress/guoxue.html" class="nav-link">国学</a></div> <a href="https://github.com/wsmjz" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/vuepress/" class="sidebar-link">首页</a></li><li><a href="/vuepress/Core/Api.html" class="sidebar-link">重要Api</a></li><li><a href="/vuepress/Core/vue.html" class="active sidebar-link">Vue概记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#一-核心" class="sidebar-link">一. 核心</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_1-多种传值方式" class="sidebar-link">1. 多种传值方式</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_2-自定义指令" class="sidebar-link">2. 自定义指令</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_3-双向数据绑定实现-（响应式）" class="sidebar-link">3. 双向数据绑定实现 （响应式）</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_4-data里的依赖收集" class="sidebar-link">4. data里的依赖收集</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_5-watch-实现原理" class="sidebar-link">5. watch 实现原理</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_6-computed-实现原理" class="sidebar-link">6. computed 实现原理</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_7-发布订阅模式" class="sidebar-link">7. 发布订阅模式</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_8-diff-虚拟节点vnode-实现" class="sidebar-link">8. **diff 虚拟节点vnode 实现</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_9-ssh服务端渲染" class="sidebar-link">9. SSH服务端渲染</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_10-权限菜单" class="sidebar-link">10. 权限菜单</a></li></ul></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#二-api" class="sidebar-link">二. Api</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#三-优化" class="sidebar-link">三. 优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_1-data-优化" class="sidebar-link">1. data() 优化</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_2-v-if" class="sidebar-link">2. v-if</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_3-v-for" class="sidebar-link">3. v-for</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_4-预渲染" class="sidebar-link">4. 预渲染</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_5-ssr服务端渲染" class="sidebar-link">5. ssr服务端渲染</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_6-用户体验-骨架屏" class="sidebar-link">6. 用户体验 骨架屏</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_7-只加载视图区内容" class="sidebar-link">7. 只加载视图区内容</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_8-路由懒加载" class="sidebar-link">8. 路由懒加载</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_9-组件异步加载" class="sidebar-link">9. 组件异步加载</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_10-使用异步组件，按需加载" class="sidebar-link">10. 使用异步组件，按需加载</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#_11-外部引入一些插件，不要在vue中引入" class="sidebar-link">11. 外部引入一些插件，不要在vue中引入</a></li></ul></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#四-vuex" class="sidebar-link">四. vuex</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#五-router" class="sidebar-link">五. router</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#六-render函数之jsx应用" class="sidebar-link">六. render函数之JSX应用</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#七-jwt认证" class="sidebar-link">七. JWT认证</a></li><li class="sidebar-sub-header"><a href="/vuepress/Core/vue.html#八-杂记" class="sidebar-link">八. 杂记</a></li></ul></li><li><a href="/vuepress/Core/react.html" class="sidebar-link">React概记</a></li><li><a href="/vuepress/webpack/my_webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/vuepress/webpack/note12.html" class="sidebar-link">zf-webpack</a></li><li><a href="/vuepress/zaji/base.html" class="sidebar-link">杂记</a></li><li><a href="/vuepress/Cansee/base.html" class="sidebar-link">可视化</a></li><li><a href="/vuepress/xcx.html" class="sidebar-link">小程序</a></li><li><a href="/vuepress/cli.html" class="sidebar-link">脚手架</a></li><li><a href="/vuepress/node_note/base/note.html" class="sidebar-link">node.js</a></li><li><a href="/vuepress/guoxue.html" class="sidebar-link">国学</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue"><a href="#vue" aria-hidden="true" class="header-anchor">#</a> Vue</h1> <ul><li>特点
<ol><li>组件级更新
<ul><li>尽量多的拆分组件：数据更新只会加载，刷新当前组件，不会（避免）更新大组件（未变数据，结构），减少性能消耗</li></ul></li> <li>单向数据流</li> <li>发布，订阅模式</li> <li>响应式数据 - 原理：数据劫持</li> <li>渐进式 - 只是解决了一小部分很重要的痛点，核心组成只提供两项最重要的功能（响应式数据，组件），然后其他为鼓励解决方案，可按需引入 - 比如路由，状态管理，构建工具链和 CLI</li></ol></li> <li>注意
<ul><li>加载顺序： props, data, computed,created</li> <li><a href="https://www.cnblogs.com/---godzilla---/p/11525035.html" target="_blank" rel="noopener noreferrer">缓存路由<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>template空标签</li> <li>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？==&gt; 因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题</li> <li>this.$children 在写组件库中重要</li> <li>组件传值不加冒号(😃 传递的为字符串</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
   aaa<span class="token punctuation">:</span> <span class="token punctuation">{</span>
     type<span class="token punctuation">:</span> Boolean<span class="token punctuation">,</span>
     <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token boolean">false</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span>cm aaa<span class="token operator">&gt;</span> <span class="token comment">// 此种写法 aaa 接受的值为true </span>
</code></pre></div><ul><li>query path / params name 传参</li></ul> <div class="language- extra-class"><pre class="language-text"><code>query 会显示在地址栏 相当于get 刷新不会丢失参数
params 会显示在地址栏 相当于post 刷新参数会丢失
</code></pre></div><ul><li>v-model修饰符
<ul><li>lazy  change事件触发</li> <li>trim 去掉前后两端的所有空格</li> <li>number</li></ul></li></ul></li> <li>VUE、MVVM框架的三要素
<ol><li>响应式：vue如何监听到data的每个属性变化？</li> <li>模板引擎：vue的模板如何被解析，指令如何处理？</li> <li>渲染：vue的模板如何被渲染成html？以及渲染过程</li></ol></li> <li>vue中如何解析模板
<ul><li>模板是什么？
<ul><li>本质：字符串</li> <li>有逻辑，如v-if v-for等</li> <li>与html很像，但有很大区别</li> <li>最终还要转化成html来显示</li> <li>模板最终要装换成js代码（render函数）</li></ul></li> <li>问题解答
<ul><li>h函数生成vdom</li> <li>patch函数渲染成dom</li></ul></li></ul></li> <li>Vue的整个实现流程
<ul><li>解析模板成render函数</li> <li>响应式开始监听</li> <li>首次渲染，显示页面，且绑定依赖</li> <li>data属性变化，触发rerender</li></ul></li> <li>cli3 集成了TypeScript
<ul><li>npm install --global @vue/cli 全局安装cli3</li> <li>选择安装TypeScript  等模块</li></ul></li> <li>SEO - 静态化处理</li> <li>Vue就是一个构造函数</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$axios <span class="token operator">=</span> ajax <span class="token comment">// 在其原型上添加方法</span>
</code></pre></div><ul><li>路由守卫 可在路由前处理做一些操作</li></ul> <h2 id="一-核心"><a href="#一-核心" aria-hidden="true" class="header-anchor">#</a> 一. 核心</h2> <h3 id="_1-多种传值方式"><a href="#_1-多种传值方式" aria-hidden="true" class="header-anchor">#</a> 1. 多种传值方式</h3> <ol><li>props / $emit 父子通信
<ul><li>.sync 可以直接在 子组件中改变 props 的</li> <li>验证（易忘点）</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>   propC<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment">// 必填的字符串</span>
      type<span class="token punctuation">:</span> String<span class="token punctuation">,</span>
      required<span class="token punctuation">:</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span>
   propF<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment">// 自定义验证函数</span>
      <span class="token function-variable function">validator</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 这个值必须匹配下列字符串中的一个</span>
      <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'success'</span><span class="token punctuation">,</span> <span class="token string">'warning'</span><span class="token punctuation">,</span> <span class="token string">'danger'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   注意那些 prop <span class="token function">会在一个组件实例创建之前进行验证，所以实例的属性</span> <span class="token punctuation">(</span>如 data、computed 等<span class="token punctuation">)</span> 在 <span class="token keyword">default</span> 或 validator 函数中是不可用的。
</code></pre></div></li> <li>ref 与 $parent / $children 适用 父子组件通信</li> <li>EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信</li> <li>dispatch - 向上查找</li> <li>$attrs/$listeners 适用于 隔代组件通信</li> <li>provide / inject 适用于 隔代组件通信</li> <li>vuex</li></ol> <h3 id="_2-自定义指令"><a href="#_2-自定义指令" aria-hidden="true" class="header-anchor">#</a> 2. 自定义指令</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> bing<span class="token punctuation">,</span> vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 三个参数值</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_3-双向数据绑定实现-（响应式）"><a href="#_3-双向数据绑定实现-（响应式）" aria-hidden="true" class="header-anchor">#</a> 3. 双向数据绑定实现 （响应式）</h3> <ul><li>数据劫持</li></ul> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     aa <span class="token operator">=</span> <span class="token number">1</span>
 <span class="token punctuation">}</span>
</code></pre></div><ul><li>什么是响应式
<ul><li>修改data属性后，vue立刻监听到</li> <li>data属性被代理到vm上</li></ul></li> <li>Object.defineProperty(obj, prop, desc) 实现响应式的核心函数</li></ul> <div class="language- extra-class"><pre class="language-text"><code>   Object.defineProperty(obj, prop, desc)的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性
   模板中没有的数据，不会走get监听，所以也不会走set监听，Object.defineProperty的原则是走get才会走set,防止无用的数据重复渲染。
</code></pre></div><ul><li>问题解答
<ul><li>关键是理解Object.defineProperty</li> <li>将data的属性代理到vm上</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>   <span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
      name<span class="token punctuation">:</span> <span class="token string">'zhangsan'</span><span class="token punctuation">,</span>
      age<span class="token punctuation">:</span> <span class="token number">20</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">var</span> key<span class="token punctuation">,</span> value
   <span class="token keyword">for</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
               <span class="token function-variable function">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 监听</span>
                  <span class="token keyword">return</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
               <span class="token punctuation">}</span><span class="token punctuation">,</span>
               <span class="token function-variable function">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">,</span> newVal<span class="token punctuation">)</span> <span class="token comment">// 监听</span>
                  data<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> newVal
               <span class="token punctuation">}</span>
         <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="_4-data里的依赖收集"><a href="#_4-data里的依赖收集" aria-hidden="true" class="header-anchor">#</a> 4. data里的依赖收集</h3> <p>在它下面定义的变量 会添加get,和set属性 -即为响应式数据 但也增加了消耗，因此静态展示数据可写在data外面，减少性能消耗</p> <h3 id="_5-watch-实现原理"><a href="#_5-watch-实现原理" aria-hidden="true" class="header-anchor">#</a> 5. watch 实现原理</h3> <h3 id="_6-computed-实现原理"><a href="#_6-computed-实现原理" aria-hidden="true" class="header-anchor">#</a> 6. computed 实现原理</h3> <h3 id="_7-发布订阅模式"><a href="#_7-发布订阅模式" aria-hidden="true" class="header-anchor">#</a> 7. 发布订阅模式</h3> <h3 id="_8-diff-虚拟节点vnode-实现"><a href="#_8-diff-虚拟节点vnode-实现" aria-hidden="true" class="header-anchor">#</a> 8. **diff 虚拟节点vnode 实现</h3> <ul><li>原则：</li></ul> <ol><li>旧0与新0比较 - 相同直接更新，不同则新节点去旧队列中查找，插入之前</li> <li>旧[length - 1]与新[lenth - 1]比较</li> <li>旧[length - 1]与新0比较</li> <li>旧0与新[length - 1]比较</li></ol> <ul><li>注意：
虚拟dom 其实就是用对象描述dom
key值为标记重用dom元素</li></ul> <h3 id="_9-ssh服务端渲染"><a href="#_9-ssh服务端渲染" aria-hidden="true" class="header-anchor">#</a> 9. SSH服务端渲染</h3> <h3 id="_10-权限菜单"><a href="#_10-权限菜单" aria-hidden="true" class="header-anchor">#</a> 10. 权限菜单</h3> <ol><li>需求</li> <li>场景应用</li></ol> <h2 id="二-api"><a href="#二-api" aria-hidden="true" class="header-anchor">#</a> 二. Api</h2> <ul><li>混入</li></ul> <div class="language- extra-class"><pre class="language-text"><code>    minxs
</code></pre></div><ul><li>继承</li> <li>响应式数据</li> <li>指令v-model 是一个语法糖 v-model='something' 相当于 v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;</li> <li>其他api
<ol><li>fordata()</li> <li>defin()</li></ol></li></ul> <h2 id="三-优化"><a href="#三-优化" aria-hidden="true" class="header-anchor">#</a> 三. 优化</h2> <h3 id="_1-data-优化"><a href="#_1-data-优化" aria-hidden="true" class="header-anchor">#</a> 1. data() 优化</h3> <p>依赖收集 - data里的数据是响应式数据 会添加getter, set属性，非响应式数据放在data外 或computed中</p> <ul><li>少用watch 耗费性能</li></ul> <h3 id="_2-v-if"><a href="#_2-v-if" aria-hidden="true" class="header-anchor">#</a> 2. v-if</h3> <p>v-if false值 里面的逻辑不会执行 v-show 只是样式display: none 里面的逻辑都会执行</p> <h3 id="_3-v-for"><a href="#_3-v-for" aria-hidden="true" class="header-anchor">#</a> 3. v-for</h3> <p>:key 值应使用唯一id 不要使用index 节点对比更改会增加性能消耗 重新渲染dom 而唯一id 对比只去改变值而已
推荐的使用key，应该理解为“使用唯一id作为key”。因为index作为key，和不带key的效果是一样的。index作为key时，每个列表项的index在变更前后也是一样的，都是直接判断为sameVnode然后复用。</p> <div class="language- extra-class"><pre class="language-text"><code>0 苹果 ----- 1 香蕉
1 香蕉 ----- 0 香蕉
2 橘子 ----- 2 香蕉
</code></pre></div><h3 id="_4-预渲染"><a href="#_4-预渲染" aria-hidden="true" class="header-anchor">#</a> 4. 预渲染</h3> <p>插件：SkeletonWebpackPlugin</p> <h3 id="_5-ssr服务端渲染"><a href="#_5-ssr服务端渲染" aria-hidden="true" class="header-anchor">#</a> 5. ssr服务端渲染</h3> <p>需要配合nodejs 在服务端先渲染出页面 再返回给客户端</p> <h3 id="_6-用户体验-骨架屏"><a href="#_6-用户体验-骨架屏" aria-hidden="true" class="header-anchor">#</a> 6. 用户体验 骨架屏</h3> <p>相当于loading</p> <h3 id="_7-只加载视图区内容"><a href="#_7-只加载视图区内容" aria-hidden="true" class="header-anchor">#</a> 7. 只加载视图区内容</h3> <p>scrollTop 计算</p> <h3 id="_8-路由懒加载"><a href="#_8-路由懒加载" aria-hidden="true" class="header-anchor">#</a> 8. 路由懒加载</h3> <p>此方法会把原本打包到一个app.js文件分开成多个js文件打包，这样会减小单个文件的大小，但是不会减小整个js文件夹的大小。通过这种方式可以做到按需加载，只加载单个页面的js文件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
   name<span class="token punctuation">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span>
   path<span class="token punctuation">:</span> <span class="token string">'/home'</span><span class="token punctuation">,</span>
   <span class="token function">component</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span>'<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>views<span class="token operator">/</span>home<span class="token punctuation">.</span>vue<span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_9-组件异步加载"><a href="#_9-组件异步加载" aria-hidden="true" class="header-anchor">#</a> 9. 组件异步加载</h3> <p>加载首页的时候，可以先给首页的子组件设置v-if = “false”，在页面初始化的时候再给子组件设置为true，此方法利用了v-if的惰性，setTimeout会使子组件在所有的组件初始化完成并显示后再对其子组件进行初始化。</p> <p>注：在实际开发中还遇到了另一种情况也可以用此方法解决，在入口js中获取了app的token，但是在具体页面中发现不管是在created还是mounted中都是有时候能获取到token，有时候又不可以，是因为执行顺序的原因，可以通过 setTimeout 时间设置为0 这种方法把用到token的请求方法给排到最后，这样就能保证请求方法中有token了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>isShow <span class="token operator">=</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_10-使用异步组件，按需加载"><a href="#_10-使用异步组件，按需加载" aria-hidden="true" class="header-anchor">#</a> 10. 使用异步组件，按需加载</h3> <div class="language-js extra-class"><pre class="language-js"><code>components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
   <span class="token string">'my-component'</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./my-async-component'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_11-外部引入一些插件，不要在vue中引入"><a href="#_11-外部引入一些插件，不要在vue中引入" aria-hidden="true" class="header-anchor">#</a> 11. 外部引入一些插件，不要在vue中引入</h3> <p>例如，我在此项目中有用到moment.js这个插件，在vue内部引入后打包的项目大小要比在外部用src的方式引入打包的项目大个300k左右。</p> <p>首先，下载好moment.min.js包，然后在vue项目的webpack.base.conf.js中添加如下代码</p> <div class="language-js extra-class"><pre class="language-js"><code>   externals<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token string">'axios'</span><span class="token punctuation">:</span> <span class="token string">'axiox'</span><span class="token punctuation">,</span>
      <span class="token string">'moment'</span><span class="token punctuation">:</span> <span class="token string">'moment'</span>
   <span class="token punctuation">}</span>
</code></pre></div><p>加上以上代码后是不会将moment.js给打包到js中的。</p> <p>最后一步，将刚才下载的moment.min.js包，手动引入到打包好的index.html 文件中。</p> <p>注：此方法真的会很有用，如果怕整个项目文件过大的话，还可以用cdn的方法引入: https://cdn.bootcss.com/moment.js/2.22.1/moment.min.js</p> <p>很重要：冒号后面大写的名字是我们自己定义的名字和项目中要使用的名字 如：‘vue’: 'Vue', 后面的Vue 必须要和项目中的保持一致。</p> <h2 id="四-vuex"><a href="#四-vuex" aria-hidden="true" class="header-anchor">#</a> 四. vuex</h2> <ul><li>同步异步方法</li> <li>dispatch</li></ul> <h2 id="五-router"><a href="#五-router" aria-hidden="true" class="header-anchor">#</a> 五. router</h2> <ul><li>hash 模式</li> <li>mode 模式</li></ul> <h2 id="六-render函数之jsx应用"><a href="#六-render函数之jsx应用" aria-hidden="true" class="header-anchor">#</a> 六. render函数之JSX应用</h2> <ol><li>模板缺陷</li> <li>函数式组件</li> <li>待整理训练营文档：<a href="http://www.zhufengpeixun.cn/train/vue-info/jsx.html#%E4%B8%80-%E6%A8%A1%E6%9D%BF%E7%BC%BA%E9%99%B7" target="_blank" rel="noopener noreferrer">地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ol> <h2 id="七-jwt认证"><a href="#七-jwt认证" aria-hidden="true" class="header-anchor">#</a> 七. JWT认证</h2> <h2 id="八-杂记"><a href="#八-杂记" aria-hidden="true" class="header-anchor">#</a> 八. 杂记</h2> <ul><li>ast 语法树</li> <li>组件
<ol><li>函数式组件</li> <li>递归组件</li> <li>全局（局部）组件</li></ol></li> <li>动态路由权限匹配</li> <li><a href="https://www.jb51.net/article/160009.htm" target="_blank" rel="noopener noreferrer">缓存组件，动态组件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
所以我们可以选择性的进行组件的缓存，也就是说你想让谁缓存，就让谁缓存，非常的自由与可配置</li> <li>extend
Vue.extend返回的是一个“扩展实例构造器”，也就是一个预设了部分选项的 Vue 实例构造器。刚学的时候对“扩展实例构造器”这一名词感觉很疑惑，其实它就像构造函数，构造函数中会事先定义好一些属性，new出来的对象也就默认有构造函数中的属性，同理Vue.extend也是如此，看下例</li> <li>$nextTick
应用场景</li> <li>SPA 单页面的理解  <a href="https://www.jianshu.com/p/b1564296a78b" target="_blank" rel="noopener noreferrer">更多<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载
<ol><li>优点
<ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li> <li>基于上面一点，SPA 相对对服务器压力小；</li> <li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul></li> <li>缺点
<ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li> <li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li> <li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul></li></ol></li> <li>v-show 与 v-if 有什么区别
v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。
所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</li> <li>Class 与 Style 如何动态绑定</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token punctuation">:</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;{ active: isActive, 'text-danger': hasError }&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span> <span class="token comment">// 对象语法</span>
<span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token punctuation">:</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;[isActive ? activeClass : '', errorClass]&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span> <span class="token comment">// 数组语法</span>

<span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token punctuation">:</span>style<span class="token operator">=</span><span class="token string">&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span> <span class="token comment">// 对象语法</span>
<span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token punctuation">:</span>style<span class="token operator">=</span><span class="token string">&quot;[styleColor, styleSize]&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span> <span class="token comment">// 数组语法</span>
<span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
      styleColor<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        color<span class="token punctuation">:</span> <span class="token string">'red'</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      styleSize<span class="token punctuation">:</span><span class="token punctuation">{</span>
        fontSize<span class="token punctuation">:</span><span class="token string">'23px'</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>Vue 的父组件和子组件生命周期钩子函数执行顺序
<ul><li>加载渲染过程
父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li> <li>子组件更新过程
父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li> <li>父组件更新过程
父 beforeUpdate -&gt; 父 updated</li> <li>销毁过程
父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li></ul></li> <li>浏览器打开一个项目打包的情况图 npm run build --report</li> <li>vue-quill-editor vue官方富文本</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">1/3/2020, 5:27:59 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/vuepress/Core/Api.html" class="prev">
          重要Api
        </a></span> <span class="next"><a href="/vuepress/Core/react.html">
          React概记
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress/assets/js/app.e32c95c2.js" defer></script><script src="/vuepress/assets/js/2.9a8b6d54.js" defer></script><script src="/vuepress/assets/js/10.11b9baea.js" defer></script>
  </body>
</html>
