<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>向上 | 苹果家+</title>
    <meta name="generator" content="VuePress 1.4.1">
    
    <meta name="description" content="欢迎各位大佬指导">
    <link rel="preload" href="/assets/css/0.styles.7a985ca1.css" as="style"><link rel="preload" href="/assets/js/app.e5c6d504.js" as="script"><link rel="preload" href="/assets/js/2.1335272e.js" as="script"><link rel="preload" href="/assets/js/8.a715e0a6.js" as="script"><link rel="prefetch" href="/assets/js/10.c6cc97db.js"><link rel="prefetch" href="/assets/js/11.a68e2a9d.js"><link rel="prefetch" href="/assets/js/12.697f59bb.js"><link rel="prefetch" href="/assets/js/13.05bee5b9.js"><link rel="prefetch" href="/assets/js/14.44450644.js"><link rel="prefetch" href="/assets/js/15.f83c08ca.js"><link rel="prefetch" href="/assets/js/16.3ec59145.js"><link rel="prefetch" href="/assets/js/17.62ad7b2d.js"><link rel="prefetch" href="/assets/js/18.4d9e73a6.js"><link rel="prefetch" href="/assets/js/19.e9118329.js"><link rel="prefetch" href="/assets/js/20.e07d3b81.js"><link rel="prefetch" href="/assets/js/21.7e895bf9.js"><link rel="prefetch" href="/assets/js/22.422a0648.js"><link rel="prefetch" href="/assets/js/23.490ee38c.js"><link rel="prefetch" href="/assets/js/24.9a1d63d4.js"><link rel="prefetch" href="/assets/js/25.7f686deb.js"><link rel="prefetch" href="/assets/js/26.b7d70968.js"><link rel="prefetch" href="/assets/js/27.0d37b13e.js"><link rel="prefetch" href="/assets/js/28.9f324f2b.js"><link rel="prefetch" href="/assets/js/29.7ad1df18.js"><link rel="prefetch" href="/assets/js/3.13637bbd.js"><link rel="prefetch" href="/assets/js/30.aa7f2fc3.js"><link rel="prefetch" href="/assets/js/31.af8efc2a.js"><link rel="prefetch" href="/assets/js/32.b0c50df3.js"><link rel="prefetch" href="/assets/js/33.480ee9fa.js"><link rel="prefetch" href="/assets/js/34.edeb0cc0.js"><link rel="prefetch" href="/assets/js/35.1df349b6.js"><link rel="prefetch" href="/assets/js/36.76316bfc.js"><link rel="prefetch" href="/assets/js/37.d48ea127.js"><link rel="prefetch" href="/assets/js/38.3fc39500.js"><link rel="prefetch" href="/assets/js/39.1a201985.js"><link rel="prefetch" href="/assets/js/4.30078826.js"><link rel="prefetch" href="/assets/js/40.689ca68b.js"><link rel="prefetch" href="/assets/js/41.cf89a22d.js"><link rel="prefetch" href="/assets/js/42.751c6ec3.js"><link rel="prefetch" href="/assets/js/43.6993de13.js"><link rel="prefetch" href="/assets/js/44.23baa205.js"><link rel="prefetch" href="/assets/js/5.0fe0dd53.js"><link rel="prefetch" href="/assets/js/6.cd4aabe9.js"><link rel="prefetch" href="/assets/js/7.4e0815f5.js"><link rel="prefetch" href="/assets/js/9.9d786d9e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7a985ca1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">苹果家+</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/wsmjz" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/wsmjz" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>向上</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jingjie/base.html" class="active sidebar-link">向上</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/jingjie/base.html#数据结构" class="sidebar-link">数据结构</a></li><li class="sidebar-sub-header"><a href="/jingjie/base.html#算法" class="sidebar-link">算法</a></li><li class="sidebar-sub-header"><a href="/jingjie/base.html#web安全" class="sidebar-link">web安全</a></li><li class="sidebar-sub-header"><a href="/jingjie/base.html#网络协议" class="sidebar-link">网络协议</a></li><li class="sidebar-sub-header"><a href="/jingjie/base.html#进阶" class="sidebar-link">进阶</a></li><li class="sidebar-sub-header"><a href="/jingjie/base.html#浏览器" class="sidebar-link">浏览器</a></li><li class="sidebar-sub-header"><a href="/jingjie/base.html#工程化-运维" class="sidebar-link">工程化.运维</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="向上"><a href="#向上" class="header-anchor">#</a> 向上</h1> <h2 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h2> <ul><li>对象</li> <li>数组</li></ul> <h2 id="算法"><a href="#算法" class="header-anchor">#</a> 算法</h2> <h3 id="排序"><a href="#排序" class="header-anchor">#</a> 排序</h3> <ul><li>冒泡</li></ul> <blockquote><p>依次向右查找<br>
O(n) 方 复杂度很大</p></blockquote> <ul><li>二分</li> <li>LRP</li></ul> <h2 id="web安全"><a href="#web安全" class="header-anchor">#</a> web安全</h2> <h2 id="网络协议"><a href="#网络协议" class="header-anchor">#</a> 网络协议</h2> <ul><li><a href="https://www.cnblogs.com/Java3y/p/8444033.html" target="_blank" rel="noopener noreferrer">文章<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>TCP握手协议(http)</li> <li>状态码具体含义</li></ul> <h2 id="进阶"><a href="#进阶" class="header-anchor">#</a> 进阶</h2> <ul><li>let 和 var 的存储地址不同</li></ul> <h2 id="浏览器"><a href="#浏览器" class="header-anchor">#</a> 浏览器</h2> <h3 id="缓存优化"><a href="#缓存优化" class="header-anchor">#</a> 缓存优化</h3> <blockquote><p>304</p></blockquote> <ul><li>强制缓存</li> <li>协商缓存</li></ul> <h3 id="垃圾回收机制原理（v8引擎）"><a href="#垃圾回收机制原理（v8引擎）" class="header-anchor">#</a> 垃圾回收机制原理（v8引擎）</h3> <ul><li>如何实现的垃圾回收</li></ul> <h3 id="浏览器是如何渲染的（渲染原理）"><a href="#浏览器是如何渲染的（渲染原理）" class="header-anchor">#</a> 浏览器是如何渲染的（渲染原理）</h3> <ul><li>输入地址亲求服务器 服务器返回html文件</li> <li>开始载入全部的html代码，发现标签内有一个标签引用外部CSS文件，浏览器又发出CSS文件的请求，服务器返回这个CSS文件；</li> <li>回流，重绘</li></ul> <h3 id="前端项目是如何运行的"><a href="#前端项目是如何运行的" class="header-anchor">#</a> 前端项目是如何运行的</h3> <ul><li>HTML,CSS,JS都是在浏览器中渲染执行的，确切的说是浏览器内核做的事情，渲染引擎和JavaScript执行引擎。</li> <li>如果是现代vue，react等框架，一般都会使用webpack构建工具，它会做一些处理例如css预处理器的解析、css前缀补全、es6+新语法向老语法的转换等等操作，都是在本地nodejs环境执行的，编译打包过后方可在浏览器端执行。</li></ul> <h2 id="工程化-运维"><a href="#工程化-运维" class="header-anchor">#</a> 工程化.运维</h2> <ul><li>配置短命令<div class="language- extra-class"><pre class="language-text"><code>vi ~/gitconfig
[alias]
   a = add -A
   c = commit -m &quot;init&quot;
   p = push origin master 
</code></pre></div></li> <li>CI(持续集成)CD持续部署</li> <li>docker
<ul><li>Docker属于Linux容器的一种封装，提供简单易用的容器使用接口</li> <li>Docker将应用程序与该程序的依赖，打包在一个文件里面，运行这个文件就会生成一个<code>虚拟容器</code> 程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样
<ul><li>Docker比虚拟机更加轻量级 性能更高 centos(虚拟机4-5G) docker 40-50M
<img src="/assets/img/docker.5b6320e6.jpg" alt=""></li></ul></li></ul></li> <li>开始 创建3个github项目
<blockquote><p>前端，服务端项目提交会向 webhook 链接的服务器（http://39.106.107:3000/webhook ）发送请求，webhook服务器 docker部署</p></blockquote> <ul><li>前端项目（配置webhook 密钥 请求方式 连接的服务器等，比如http://39.106.107:3000/webhook）</li> <li>服务端项目（配置webhook 密钥 请求方式 连接的服务器等，比如http://39.106.107:3000/webhook）</li> <li>webhook项目(CICD服务器)
<ul><li>webhook.js中 创建服务 // 上面配置的 这儿监听3000端口
<ul><li>判断 路劲是不是 上面配置的<code>/webhook</code></li></ul></li> <li>提交前后端项目 这儿就会收到请求</li></ul></li></ul></li> <li>操作Xshell（在Xshell中）
<ul><li>下载 git</li> <li>下载前端(vue-front) 服务端(vue-back)项目(生成公钥 免输密码)
<ul><li>git clone ...项目</li> <li>ssh-keygen -t rsa -b ...（免密）</li> <li>cat 查找文件 查看生成公钥（Xshell内容）</li></ul></li> <li>下载node(nvm 管理node 可以存在多个node版本)
<ul><li>nvm install stable 同时安装node npm</li> <li>npm install nrm -g (切换安装源)</li> <li>开放阿里云接口</li></ul></li> <li>安装docker
<ul><li>安装阿里云镜像</li></ul></li> <li>安装启动服务
<ul><li>cd vue-front/back 进入前端/服务端文件夹</li> <li>npm i 安装依赖</li> <li>npm start 启动项目</li></ul></li></ul></li></ul> <h3 id="流程图"><a href="#流程图" class="header-anchor">#</a> <a href="http://www.sohu.com/a/338934428_100299155" target="_blank" rel="noopener noreferrer">流程图<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <p>编码 =&gt; 构建(build, 安装依赖等) =&gt; 测试 =&gt; 集成(分支测试通过，集成到主干) =&gt; 交付 =&gt; 部署
<img src="https://upload-images.jianshu.io/upload_images/2414212-120ea11d15068afd" alt="avatar"></p> <ol><li>编码到集成 叫做 持续集成</li> <li>编码到交付 叫做 持续交付</li> <li>编码到部署 叫做 持续部署</li></ol> <h3 id="webpack"><a href="#webpack" class="header-anchor">#</a> webpack</h3> <h3 id="自动化测试"><a href="#自动化测试" class="header-anchor">#</a> 自动化测试</h3> <h3 id="自动化部署-一次"><a href="#自动化部署-一次" class="header-anchor">#</a> 自动化部署(一次)</h3> <ol><li>webHook</li> <li>Docker镜像 Nglix代理</li></ol> <h3 id="持续集成（continuous-integration，简称-ci）"><a href="#持续集成（continuous-integration，简称-ci）" class="header-anchor">#</a> 持续集成（Continuous integration，简称 CI）</h3> <ul><li>关键：(持续， 多次)<a href="https://www.jianshu.com/p/c200884960ac" target="_blank" rel="noopener noreferrer">解释1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://www.jianshu.com/p/78e03a140125" target="_blank" rel="noopener noreferrer">解释2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>概念</li></ul> <blockquote><p>1、持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。许多团队发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度（以上引用自Martin Fowler 对持续集成的定义）。<br>
2、持续集成指的是，频繁地（一天多次）将代码集成到主干</p></blockquote> <ul><li>为什么使用
时常我们会被集成折磨得焦头烂额。有很多团队只是担心，并没有拿出有效的措施去避免这种事情发生，以至于延长了交付时间。既然担心，我们何不及早集成，把问题先暴露出来？ 最后集成会出现很多问题，所以提前这样去把问题暴露出来</li> <li>好处</li></ul> <blockquote><p>1、快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。<br>
2、防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。<br>
3、减少风险<br>
4、减少重复过程</p></blockquote> <ul><li>目的</li></ul> <blockquote><p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。
Martin Fowler 说过，”持续集成并不能消除 Bug，而是让它们非常容易发现和改正。”</p></blockquote> <ul><li>工具</li></ul> <blockquote><p>GitHub 上比较主流的持续集成工具有 Travis CI 和 Circle CI；分别占市场占有率前两位，两者的功能和使用都比较相似，其中Travis CI用的最多</p></blockquote> <ul><li>总结
<blockquote><p>1、持续突出的就是一个<strong>快</strong>字，商业软件的快速落地需求推动了软件工程的发展。可持续的、<strong>快速迭代</strong>的软件过程是当今主流开发规约。尤其在互联网行业，快速响应即是生命线。从一个想法到产品落地都处在冲锋的过程中，机会稍纵即逝。响应用户反馈也是万分<strong>敏捷</strong>，早晨的反馈在当天就会上线发布，快得让用户感觉倍受重视。“快”已经成为商业竞争力。这一切都要求企业具备快速响应的能力，这正是推动持续集成、持续交付、持续部署的动力<br>
2、产品或者项目的参与者应该能够深刻体会到团队协作时，工作交接（系统集成）部分最容易出问题，会消耗大量的沟通成本与时间成本，直接拖慢进度。所以，一个行之有效的项目管理过程（包括沟通管理、流程管理）在大型项目中效果明显。当前<strong>敏捷开发</strong>是主流，持续集成、持续交付与持续部署正好能够帮助高效地实施敏捷过程，促进开发、运维和质量保障（QA）部门之间的沟通、协作与整合</p></blockquote></li></ul> <h4 id="ci-cd-带来的变化"><a href="#ci-cd-带来的变化" class="header-anchor">#</a> CI&amp;CD 带来的变化</h4> <p>目前多数公司都已经使用了版本管理工具来管理源码，比如GitLab、SVN 等版本管理工具。在版本管理这一块，公司会根据自己的实际情况来制订版本管理办法。对于持续集成来说，业内建议只维护一个源码仓库，降低版本管理的复杂度。开发人员<strong>持续提交自己的修改，自动触发编译，自动集成，自动进行自动化的测试</strong>，及早反馈集成过程中的问题，就能更好地防止出现平时不集成、集成就出问题的现象<br>
通过自动化的持续集成，把管理流程固化；保证集成的有序性、可靠性；减少版本发布的不合规性（开发或者测试手动打包，可能一天打多个包，更新多次，测试不充分），保证版本可控，问题可追溯（至于哪个版本出现的问题，可以回溯）。<br></p> <p>一旦把这种持续集成的过程固定下来，形成一个自动化过程，就具备了持续集成的能力，软件交付的可靠性就大大增强，这无形也是一种竞争力。这种竞争力保证了集成的有序性、可靠性。过程的自动化抛弃了人工，降低了出错率，提高了速度，自然会节省成本。</p> <h4 id="ci-cd-实施现状"><a href="#ci-cd-实施现状" class="header-anchor">#</a> CI&amp;CD 实施现状</h4> <p>在日常生活中处处都体现着一个“快”字，互联网更是对快追求到极致。持续集成、持续交付、持续部署在互联网行业更为广泛。作者没有统计哪些公司在用，只是圈子中朋友公司都实施了持续集成，具备持续交付能力。至于持续部署就没这么广泛了，毕竟<strong>持续部署不仅仅是技术问题，还涉及管理、营运等问题</strong>。尤其是一些金融企业、大型国企，开发团队外包，测试外包，运营半外包，安全要求高，很难快速实施。多数能够在测试环境中建立起CI&amp;CD就已经很不错了。<br></p> <p>阿里云、腾讯云、网易蜂巢等国内云，都提供了从GitLab 下拉代码、编译打包、单元测试、镜像制作、容器发布的功能。这个过程实际上就是持续集成、持续交付的过程，同时具有持续部署的能力。基本上，持续集成、持续交付、持续部署是一种服务能力，是云平台必须具备的能力。</p> <h4 id="ci-cd-技术栈"><a href="#ci-cd-技术栈" class="header-anchor">#</a> CI&amp;CD 技术栈</h4> <p>目前持续集成、持续交付、持续部署在开源社区都是热点，用户可以方便地利用这些开源组件来构建自己企业的持续集成、持续交付及持续部署平台。<br></p> <p>持续集成工具中以Jenkins 使用最为广泛，由Jenkins 来作业化持续集成过程；利用GitLab来管理程序版本；利用Gerrit 来做代码审核；利用<strong>Sonar 进行代码质量扫描</strong>；利用JUnit 进行单元测试；利用Docker compose 来构建镜像；利用Docker 来部署容器；利用Kubernetes、Rancher 等进行服务编排。
<img src="https://upload-images.jianshu.io/upload_images/2414212-ab595553429f08c3" alt="avatar"></p> <h3 id="持续交付"><a href="#持续交付" class="header-anchor">#</a> 持续交付</h3> <p>持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。
持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p> <h3 id="持续部署"><a href="#持续部署" class="header-anchor">#</a> 持续部署</h3> <ul><li>持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</li> <li>持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</li> <li>持续部署的前提是能自动化完成测试、构建、部署等步骤</li> <li>流程</li></ul> <ol><li>提交代码(commit)
流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。</li> <li>测试(第一轮)
<ul><li>代码仓库对 commit 操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。</li> <li>测试有好几种。</li></ul> <ol><li>单元测试：针对函数或模块的测试</li> <li>集成测试：针对整体产品的某个功能的测试，又称功能测试</li> <li>端对端测试：从用户界面直达数据库的全链路测试
第一轮至少要跑单元测试。</li></ol></li> <li>构建</li></ol> <blockquote><p>通过第一轮测试，代码就可以合并进主干，就算可以交付了。
交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS 脚本、图片）等等。
常用的构建工具如下。</p></blockquote> <ul><li>Jenkins</li> <li>Travis</li> <li>Codeship</li> <li>Strider</li></ul> <blockquote><p>Jenkins 和 Strider 是开源软件，Travis 和 Codeship 对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成</p></blockquote> <ol start="4"><li>测试(第二轮)</li></ol> <blockquote><p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。
第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。
需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。</p></blockquote> <ol start="5"><li>部署</li></ol> <blockquote><p>通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。
生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有 Ansible，Chef，Puppet 等。</p></blockquote> <ol start="6"><li>回滚</li></ol> <blockquote><p>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。</p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e5c6d504.js" defer></script><script src="/assets/js/2.1335272e.js" defer></script><script src="/assets/js/8.a715e0a6.js" defer></script>
  </body>
</html>
